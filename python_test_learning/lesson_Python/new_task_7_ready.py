"""Задание:
Сдвинуть массив [1..n] циклически влево (вправо) на m позиций.
«Падающие» элементы должны уходить в хвост (в голову).
"""

def check_input(x):
    while True:
        try:
            check = int(input(x))
            return check
        except ValueError:
            print('Введены некорректные данные. Давай попробуем снова.')


n = check_input('Введите максимальное значение в массиве n (кроме 1): ')
while n == 1 :
   print('Массив принимает форму числового ряда начинающегося с 1, '
         'поэтому он не может заканчиваться также на 1. ')
   n = check_input('Повторно введите максимальное значение в массиве n (кроме 1): ')

m = check_input('Введите m (количество циклов сдвига): ')
while m < 0 :
   print('Количество циклов сдвига не может быть отрицательным значением. Давай попробуем ещё раз.')
   m = check_input('Введите m (количество циклов сдвига): ')

valid_direct = ('l','r','R','L')                        # массив с валидными вариантами ввода направления сдвига
direct = str(input('Укажите направление сдвига (L или R): '))
while direct not in valid_direct:
    print('Для указания направления сдвига можно использовать только L и R')
    direct = str(input('Ещё раз укажите направление сдвига (L или R): '))

cycle = 0                   # переменная циклов

if n <= 0:                       # переменная для создания диапазона,
    x = -1                       # которая управляет эндом массива и шагом в зависимости от ввода макса массива
elif n > 0:                      # отрицательный при нулевом или отрицательном максе и переходе через 0,
    x = 1                        # положительный при положительном максе

user_range = range(1, n + x, x)         # создаём диапазон из ввода
user_list = []                          # создаём пустой список

for y in user_range:                    # делаем прогон всего диапазона
    user_list.append(y)                 # с записью каждого элемента в массив

old_user_list = user_list.copy()        # создадим на память копию массива чтобы потом с ним сравниться
print(user_list)

if m == 0:
    print(f'Массив до изменений: {old_user_list}')
    print(f'Массив после изменений: {user_list}')
    print(f'Массив не изменился, сдвигов не было, потому что было указано {m} циклов сдвига.')
    exit()

elif direct == 'L' or direct == 'l':                        # если налево пойдёшь...
    while cycle < m:                                        # запустится цикл сдвигов
        number = user_list[0]                               # сохраним крайний левый элемент в переменную перед удалением
        del user_list[0]                                    # удалим крайний левый элемент
        user_list.append(number)                            # добавим удалённый элемент из переменной в конец списка
        cycle += 1
    print(f'Массив до изменений: {old_user_list}')
    print(f'Массив после изменений: {user_list}')
    print(f'Произведён сдвиг на {m} элементов ВЛЕВО <<<---')
    exit()

elif direct == 'R' or direct == 'r':                        # если направо пойдёшь...
    while cycle < m:                                        # запустится цикл сдвигов
        z = len(user_list) - 1                              # переменная крайнего правого индекса, равная длинне массива минус 1
        number = user_list[z]                               # сохраним крайний правый элемент в переменную перед удалением
        del user_list[z]                                    # удалим крайний правый элемент
        user_list.insert(0, number)                  # добавим удалённый элемент из переменной в список на 0 индекс
        cycle += 1                                          # повторим сколько треб
    print(f'Массив до изменений: {old_user_list}')
    print(f'Массив после изменений: {user_list}')
    print(f'Произведён сдвиг на {m} элементов ВПРАВО --->>>')
    exit()

else:
    print('Это сообщение никто не должен увидеть. '
          'Но если его видно, то, похоже, кто-то накосячил в коде...')
    exit()
