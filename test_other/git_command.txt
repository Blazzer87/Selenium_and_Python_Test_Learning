git clone {https:// url репозитория}
скачивает проект с гита. клонирует удалённый репозиторий, создавая локальную папку с полным историческим графом и автоматически настраивая origin для git push/git pull

git commit -m "тут какое-то название коммита"
выгрузка всех изменений в некую условную базу данных гита, после чего он запоминает изменения и присваивает айдишник для этой версии.
фиксирует уже проиндексированные (git add) изменения в локальной истории (создаёт новый коммит с SHA-1), сообщение — обязательное краткое описание.

git add . / git add <тутфайл>
эта команда перемещает файл в стейдж(индекс) и дальше при команде git commit будут отправлены в гит только файлы из стейджа
если ТОЧКА - в индекс/стейдж добавятся все файлы в этом уровне и ниже
есил ФАЙЛ - то только конкретный

git add module_python/allure/test.py
эта команда перемещает файл в стейдж(индекс) только указанный файл

git branch test-branch1
создание новой ветки test-branch1 НО БЕЗ переключения на неё! коммит после создания приведёт к коммиту в master/main ветку
ветка - последовательность комитов начиная от какого то комита в прошлом

git checkout test-branch1
переключится на свою созданную ветку test-branch1. коммиты после этой команды будут вливаться сюда

git checkout -b test-branch1
сочетает branch + checkout - создать ветку и сразу переключиться

git switch -c <имя> = git checkout -b <имя>
альтернативный вариант создать и переключиться через switch

git switch <имя> = git checkout <имя>
альтернативный вариант переключиться через switch

git push origin test-branch1
слить в удалённый репозиторий НО В ВЕТКУ test-branch1, а не main.
origin - это короткое название нашего удалённого репозитория чтобы не писать длинный урл

git pull origin {ветка репозитория}
скачать из удалённого репозитория ветку test-branch1
эквивалент = git fetch origin <ветка> + git merge origin/<ветка>

git rebase master
перенести все изменения сделанные в ветке test-branch1 в ветку master
выполняется копированием, ветка test-branch1 сохраняется

git revert {хеш коммита}
создаёт новый коммит, в котором происходит отмена всех изменений которые были сделаны в коммите который указан в команде

git merge bugFix (находясь в main)
сливание ветки test-branch1 в ветку текущего местонахождения
после этого main (или иная ветка текущего местонахождения) имеет полный набор кода из своих комитов и чужих

git checkout bugFix; git merge main
дообновляет bugFix до состояния самой актуальной версии так же как и main (фактически не создаёт нового комита)

git rebase main (находясь в bugFix)
скопирует все коммиты из ветки bugFix в ветку main в последовательном порядке. но после этого требуется обновить ветку main в обратную сторону
git rebase bugFix (находясь в main)
cинхронизирует обе ветки приводя их к единому актуальному состоянию

git checkout test-branch5^
Перемещение на один коммит назад ^ от последнего/текущего состояния ветки test-branch5 (т.к. привязка к текущему сосотоянию то можно вренуться только на ё коммит назад)

git checkout HEAD^
Перемещение на один коммит назад ^, но за точку отсчёта берётся текущий HEAD (условно экран), что позволя ступенчато переключаться на шаг назад

git checkout HEAD~3
Перемещение на несколько коммитов назад ~<num>

git checkout {хеш коммита}
Перемещение на определёный локальный коммит в прошлом

git checkout {ветка репозитория}
вернуться назад к последнему сосотоянию ветки мейн

git branch -f main HEAD~3
Переместит (принудительно) ветку main на 3 родителя назад от HEAD. -f это branch forcing

git branch -f bugFix <commit-hash>
Переместит (принудительно) ветку bugFix на коммит с6. -f это branch forcing

git reset
отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории";

git reset HEAD~2
Откатывает текущую ветку на 2 коммита назад, сохраняя изменения в файлах

git revert HEAD
создаётся новый коммит C2' который содержит изменения, полностью противоположные тем, что сделаны в коммите из которого выполняется команда

git cherry-pick <commit-hash>
Находясь в ветке куда необходимо перенести изменения сделанные в одном коммите, без необходимости сливать всю ветку.
После разрешения конфликтов необходимо завершить процесс cherry-pick с помощью:
git cherry-pick --continue
отменить cherry-pick с помощью:
git cherry-pick --abort

git init
сообщает гиту о том что данную папку нужно превратить в репозиторий. Предварительно нужно через cd перейти в эту папку
далее создаётся удалённый репозиторий на github.com и можно связать local с origin

git remote add origin {https:// url репозитория}
соединяет локальный репозиторий с удалённым, доступным по данному url

git status
показывает статус всех несохранённых (незакоммиченых) изменений в файлах внутри репозитория

git log
показывает историю всех коммитов в данной ветке с их хешами и сообщениями (для выхода нажать 'q')

git log --oneline --graph --decorate
компактная визуализация лога

git branch
выводит список всех локальных веток доступный в этом локальном репозитории

git diff
Показывает различия между рабочей директорией и индексом
git diff --staged
Показывает различия между индексом и последним коммитом

git reset <тутназваниефайла.пу>
Убирает файл из staging area
git reset --hard
Откатывает все изменения до последнего коммита

git fetch
Загружает изменения из origin (без слияния)