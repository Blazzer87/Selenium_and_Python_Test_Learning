
test-branch1, test-branch2  - название веток,

git clone {https:// url репозитория}
скачивает проект с гита

git commit -m "тут какое-то название коммита"
выгрузка всех изменений в некую условную базу данных гита, после чего он запоминает изменения и присваивает айдишник для этой версии.

git add module_python/allure/test.py
эта команда перемещает файл в стейдж(индекс) и дальше при команде гит коммит будут отправлены в гит только файлы из стейджа

git add .
точка - в индекс/стейдж добавятся все файлы в этом уровне и ниже

git branch test-branch1
создание новой ветки test-branch1 НО БЕЗ переключения на неё! коммит после создания приведёт к коммиту в master/main ветку
ветка - последовательность комитов начиная от какого то комита в прошлом

git checkout test-branch1
переключится на свою созданную ветку test-branch1. коммиты после этой команды будут вливаться сюда

git checkout -b test-branch1 - создать ветку и сразу переключиться

git push origin test-branch1
слить в удалённый репозиторий НО В ВЕТКУ test-branch1, а не main. На Гитхабе уже должна быть создана ветка с таким названием.
origin - это короткое название нашего удалённого репозитория чтобы не писать длинный урл

git pull origin test-branch1
скачать из удалённого репозитория ветку test-branch1

git rebase master
слить все изменения сделанные в ветке test-branch1 в ветку master
выполняется копированием, ветка test-branch1 сохраняется

git revert айдишник конкретного коммита
создаёт новый коммит, в котором происходит отмена всех изменений которые были сделаны в коммите который указан в команде

git merge bugFix (находясь в main)
сливание ветки test-branch1 в ветку текущего местонахождения
после этого main (или иная ветка текущего местонахождения) имеет полный набор кода из своих комитов и чужих

git checkout bugFix; git merge main
дообновляет bugFix до состояния самой актуальной версии так же как и main (фактически не создаёт нового комита)

git rebase main (находясь в bugFix)
скопирует все коммиты из ветки bugFix в ветку main в последовательном порядке. но после этого требуется обновить ветку main в обратную сторону
git rebase bugFix (находясь в main)
cинхронизирует обе ветки приводя их к единому актуальному состоянию

git checkout test-branch5^
Перемещение на один коммит назад ^ от последнего/текущего состояния ветки test-branch5 (т.к. привязка к текущему сосотоянию то можно вренуться только на ё коммит назад)

git checkout HEAD^
Перемещение на один коммит назад ^, но за точку отсчёта берётся текущий HEAD (условно экран), что позволя ступенчато переключаться на шаг назад

git checkout HEAD~3
Перемещение на несколько коммитов назад ~<num>

git branch -f main HEAD~3
Переместит (принудительно) ветку main на 3 родителя назад от HEAD. -f это branch forcing

git branch -f bugFix <commit-hash>
Переместит (принудительно) ветку bugFix на коммит с6. -f это branch forcing

git reset
отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории";

git reset HEAD~2

git revert HEAD
создаётся новый коммит C2' который содержит изменения, полностью противоположные тем, что сделаны в коммите из которого выполняется команда

git cherry-pick <commit-hash>
Находясь в ветке куда необходимо перенести изменения сделанные в одном коммите, без необходимости сливать всю ветку.
После разрешения конфликтов необходимо завершить процесс cherry-pick с помощью:
git cherry-pick --continue
отменить cherry-pick с помощью:
git cherry-pick --abort



git init
сообщает гиту о том что данную папку нужно превратить в репозиторий.Предварительно нужно через cd перейти в эту папку

далее создаётся удалённый репозиторий на github.com

git remote add origin {https:// url репозитория}
соединяет локальный репозиторий с удалённым, доступным по данному url

git status
показывает статус всех несохранённых (незакоммиченых) изменений в файлах внутри репозитория

